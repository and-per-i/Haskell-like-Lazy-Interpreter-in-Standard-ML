use "lexer.sml";
use "parser.sml";

(*
 * This section defines the evaluator for the Abstract Syntax Tree (AST)
 * generated by the parser. It takes an AST expression and computes its value.
 *)

(* Define the possible types of values that expressions can evaluate to *)
datatype value =
    VInt of int
  | VBool of bool
  | VString of string (* NEW: String value *)
  | VLit  of char
  | VError of string (* For unsupported features or runtime errors *)
  | VThunk of (expr * env ref * value option ref ) (* Thunk constructor for lazy evaluation *)
and  env = EnvList of  (string * value ) list;





(* Helper to convert a value to a string for printing *)
fun valueToString val_ =
    case val_ of
        VInt i => Int.toString i
      | VBool b => if b then "True" else "False"
      | VString s => "\"" ^ s ^ "\"" (* NEW: Convert VString to string *)
      | VLit  c => "'" ^ Char.toString c ^ "'"
      | VError s => "ERROR: " ^ s
    
    | VThunk (_, _, ref_opt) => (* Show if it's a forced or unforced thunk *)
          (case !ref_opt of
               SOME v => "THUNK(FORCED: " ^ (valueToString v) ^ ")"
             | NONE => "THUNK(UNFORCED)")



(* `eval_expr` function: Entry point for evaluation, always passes an `env ref`. *)
fun eval_expr (ast: expr, environment_ref: env ref) : value = (* Takes env ref *)
    case ast of
        IntLit n => VInt n
      | BoolLit b => VBool b
      | StringLit s => VString s
      | CharLit c => VLit c
        (* For atomic expressions or those that delegate to internal eval, dereference and pass *)
      | Var s => EVAL_EXPR_INTERNAL (Var s, !environment_ref)
      | BinOp (s, e1, e2) => EVAL_EXPR_INTERNAL (BinOp (s, e1, e2), !environment_ref)
      | IfThenElse (cond_expr, then_expr, else_expr) => EVAL_EXPR_INTERNAL (IfThenElse (cond_expr, then_expr, else_expr), !environment_ref)
      | ParenExpr e => EVAL_EXPR_INTERNAL (ParenExpr e, !environment_ref)
      | Let (bindings, in_expr) => EVAL_EXPR_INTERNAL (Let (bindings, in_expr), !environment_ref)
    


(* UPDATED: forceValue function - now takes a value and memoizes its result *)



(*
 * `EVAL_EXPR_INTERNAL` function:
 * This is the core evaluation logic. It takes a concrete `env` (not `env ref`).
 * It's separated so `forceValue` can call it directly with its dereferenced environment.
 *)
and EVAL_EXPR_INTERNAL (ast: expr, environment: env) : value =
    case ast of
        IntLit n => VInt n
      | BoolLit b => VBool b
      | StringLit s => VString s
      | CharLit c => VLit c
      | Var s =>
            (case environment of
                EnvList env_list =>
                    (print ("DEBUG: Looking up variable '" ^ s ^ "' in environment:\n");
                     List.app (fn (name, v) => print ("    " ^ name ^ " = " ^ (valueToString v) ^ "\n")) env_list;
                     (case List.find (fn (name, _) => name = s) env_list of
                         SOME (_, v) =>
                              let
                                 val forced_v = forceValue v; 
                                 val () = print ("DEBUG: Variable '" ^ s ^ "' forced to: " ^ (valueToString forced_v) ^ "\n");
                             in
                                 forced_v
                             end
                       | NONE => VError ("Unbound variable: " ^ s))))
      | BinOp (s, e1, e2) =>
            let
                val v1 = eval_expr (e1, ref environment)
                val v2 = eval_expr (e2, ref environment)
            in
                case (v1, v2) of
                    (VInt i1, VInt i2) =>
                        (case s of
                             "+" => VInt (i1 + i2)
                           | "*" => VInt (i1 * i2)
                           | "==" => VBool (i1 = i2)
                           | ">" => VBool (i1 > i2)
                           | "<" => VBool (i1 < i2)
                           | _ => VError ("Unsupported binary operator for integers: " ^ s))
                    | (VString s1, VString s2) => (* String concatenation *)
                        (case s of
                             "++" => VString (s1 ^ s2)
                           | _ => VError ("Unsupported binary operator for strings: " ^ s))
                    | _ => VError ("Type error: Binary operation " ^ s ^ " expects consistent types, got " ^ (valueToString v1) ^ " and " ^ (valueToString v2))
            end

      
      | IfThenElse (cond_expr, then_expr, else_expr) =>
            let
                val cond_val = forceValue (eval_expr (cond_expr, ref environment)); (* Pass ref *)
            in
                case cond_val of
                    VBool true => eval_expr (then_expr, ref environment) (* Pass ref *)
                  | VBool false => eval_expr (else_expr, ref environment) (* Pass ref *)
                  | _ =>  VError ("Type error: If condition expects boolean, got " ^ (valueToString cond_val))
            end
      | ParenExpr e => eval_expr (e, ref environment) (* Pass ref *)
      | Let (bindings, in_expr) =>
            let
                (* 1. Create a mutable reference for the environment that will contain
                   the new, mutually recursive let bindings. Initialize it to the *outer* environment.
                   This makes the `ref` immediately point to a valid (though incomplete) environment. *)
                val let_env_ref : env ref = ref environment; (* Initialize with the outer env *)

                (* 2. Create the VThunks for each binding. Each thunk's environment
                   is set to `let_env_ref` (the reference itself!). This is the "tying the knot" step:
                   the thunks implicitly refer to the environment that is *being built*. *)
                val lazy_bindings =
                    List.map (fn (name, bound_expr) =>
                        (name, VThunk (bound_expr, let_env_ref, ref NONE))) (* Thunks capture the ref to the environment *)
                        bindings;

                (* 3. Construct the full environment for this `let` block.
                   This involves prepending the lazy bindings to the environment
                   that `let_env_ref` initially contained (the outer environment). *)
                val (EnvList outer_env_list) = environment;
                val new_env_list = lazy_bindings @ outer_env_list;

                (* 4. Update the mutable reference `let_env_ref` to point to this
                   newly constructed full environment. Now, all `VThunk`s created in step 2
                   correctly point to this complete, self-referential environment when they are forced. *)
                val () = let_env_ref := EnvList new_env_list;

            in
                (* 5. Evaluate the 'in_expr' (the body of the let) using the newly
                   established mutually recursive environment. *)
                eval_expr (in_expr, let_env_ref) (* Pass the ref *)
            end
        



    

and  forceValue (val_: value) : value =
    case val_ of
        VThunk (expr_to_force, thunk_env_ref, memo_ref) => (* Correctly destructures the VThunk *)
            (case !memo_ref of
                 SOME computed_value =>
                     (* If already computed, return the memoized value *)
                     computed_value
               | NONE =>
                   (* If not computed, evaluate it using eval_expr *)
                   let
                       val result = eval_expr (expr_to_force, thunk_env_ref)
                   in
                       memo_ref := SOME result; (* Memoize the result in the ref *)
                       result
                   end)
      | _ => val_ (* If it's not a VThunk, just return the value itself *)

